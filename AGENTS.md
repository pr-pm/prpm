<!-- Generated by Ruler -->


<!-- Source: .ruler/openskills.md -->

<skills_system priority="1">

## Available Skills

<!-- SKILLS_TABLE_START -->
<usage>
When users ask you to perform tasks, check if any of the available skills below can help complete the task more effectively. Skills provide specialized capabilities and domain knowledge.

How to use skills:
- Invoke: Bash("npx openskills read <skill-name>")
- The skill content will load with detailed instructions on how to complete the task
- Base directory provided in output for resolving bundled resources (references/, scripts/, assets/)

Usage notes:
- Only use skills listed in <available_skills> below
- Do not invoke a skill that is already loaded in your context
- Each skill invocation is stateless
</usage>

<available_skills>

<skill>
<name>agent-builder</name>
<description>Use when creating, improving, or troubleshooting Claude Code subagents. Expert guidance on agent design, system prompts, tool access, model selection, and best practices for building specialized AI assistants.</description>
<location>project</location>
</skill>

<skill>
<name>aws-beanstalk-expert</name>
<description>Expert knowledge for deploying, managing, and troubleshooting AWS Elastic Beanstalk applications with production best practices</description>
<location>project</location>
</skill>

<skill>
<name>beanstalk-deploy</name>
<description>"Robust deployment patterns for Elastic Beanstalk with GitHub Actions, Pulumi, and edge case handling"</description>
<location>project</location>
</skill>

<skill>
<name>claude-hook-writer</name>
<description>Expert guidance for writing secure, reliable, and performant Claude Code hooks - validates design decisions, enforces best practices, and prevents common pitfalls</description>
<location>project</location>
</skill>

<skill>
<name>creating-agents-md</name>
<description>Use when creating agents.md files - provides plain markdown format with NO frontmatter, free-form structure, and project context guidelines for AI coding assistants</description>
<location>project</location>
</skill>

<skill>
<name>creating-claude-agents</name>
<description>Use when creating or improving Claude Code agents. Expert guidance on agent file structure, frontmatter, persona definition, tool access, model selection, and validation against schema.</description>
<location>project</location>
</skill>

<skill>
<name>creating-claude-commands</name>
<description>Expert guidance for creating Claude Code slash commands with correct frontmatter, structure, and best practices</description>
<location>project</location>
</skill>

<skill>
<name>creating-claude-hooks</name>
<description>Use when creating or publishing Claude Code hooks - covers executable format, event types, JSON I/O, exit codes, security requirements, and PRPM package structure</description>
<location>project</location>
</skill>

<skill>
<name>creating-continue-packages</name>
<description>Use when creating Continue rules - provides required name field, alwaysApply semantics, glob/regex patterns, and markdown format with optional frontmatter</description>
<location>project</location>
</skill>

<skill>
<name>creating-copilot-packages</name>
<description>Use when creating GitHub Copilot instructions - provides repository-wide and path-specific formats, applyTo patterns, excludeAgent options, and natural language markdown style</description>
<location>project</location>
</skill>

<skill>
<name>creating-cursor-commands</name>
<description>Expert guidance for creating effective Cursor slash commands with best practices, format requirements, and schema validation</description>
<location>project</location>
</skill>

<skill>
<name>creating-cursor-rules-skill</name>
<description>Expert guidance for creating effective Cursor IDE rules with best practices, patterns, and examples</description>
<location>project</location>
</skill>

<skill>
<name>creating-kiro-agents</name>
<description>Use when building custom Kiro AI agents or when user asks for agent configurations - provides JSON structure, tool configuration, prompt patterns, and security best practices for specialized development assistants</description>
<location>project</location>
</skill>

<skill>
<name>creating-kiro-packages</name>
<description>Use when creating Kiro steering files or hooks - provides inclusion modes (always/fileMatch/manual), foundational files (product.md/tech.md/structure.md), and JSON hook configuration with event triggers</description>
<location>project</location>
</skill>

<skill>
<name>creating-skills</name>
<description>Use when creating new Claude Code skills or improving existing ones - ensures skills are discoverable, scannable, and effective through proper structure, CSO optimization, and real examples</description>
<location>project</location>
</skill>

<skill>
<name>creating-windsurf-packages</name>
<description>Use when creating Windsurf rules - provides plain markdown format with NO frontmatter, 12,000 character limit, and single-file structure requirements</description>
<location>project</location>
</skill>

<skill>
<name>documentation-standards</name>
<description>Standards and guidelines for organizing, structuring, and maintaining documentation in the PRPM repository - ensures consistency across user docs, development docs, and internal references</description>
<location>project</location>
</skill>

<skill>
<name>elastic-beanstalk-deployment</name>
<description>Use when deploying Node.js applications to AWS Elastic Beanstalk or troubleshooting deployment issues - provides dependency installation strategies, monorepo handling, and deployment best practices</description>
<location>project</location>
</skill>

<skill>
<name>github-actions-testing</name>
<description>Expert guidance for testing and validating GitHub Actions workflows before deployment - catches cache errors, path issues, monorepo dependencies, and service container problems that local testing misses</description>
<location>project</location>
</skill>

<skill>
<name>human-writing</name>
<description>Write content that sounds natural, conversational, and authentically human - avoiding AI-generated patterns, corporate speak, and generic phrasing</description>
<location>project</location>
</skill>

<skill>
<name>integrating-stripe-webhooks</name>
<description>Use when implementing Stripe webhook endpoints and getting 'Raw body not available' or signature verification errors - provides raw body parsing solutions and subscription period field fixes across frameworks</description>
<location>project</location>
</skill>

<skill>
<name>karen-repo-reviewer</name>
<description>Use when the user requests a repository review, code assessment, or honest evaluation of their codebase. Provides brutally honest AI-powered reviews with market-aware Karen Scores (0-100) analyzing over-engineering, completion honesty, and practical value. Available as GitHub Action or IDE tool.</description>
<location>project</location>
</skill>

<skill>
<name>postgres-migrations</name>
<description>Comprehensive guide to PostgreSQL migrations - common errors, generated columns, full-text search, indexes, idempotent migrations, and best practices for database schema changes</description>
<location>project</location>
</skill>

<skill>
<name>prpm-json-best-practices</name>
<description>Best practices for structuring prpm.json package manifests with required fields, tags, organization, multi-package management, enhanced file format, and conversion hints</description>
<location>project</location>
</skill>

<skill>
<name>pulumi-troubleshooting</name>
<description>Comprehensive guide to troubleshooting Pulumi TypeScript errors, infrastructure issues, and best practices - covers common errors, Outputs handling, AWS Beanstalk deployment, and cost optimization</description>
<location>project</location>
</skill>

<skill>
<name>self-improving</name>
<description>Use when starting infrastructure, testing, deployment, or framework-specific tasks - automatically searches PRPM registry for relevant expertise packages and suggests installation to enhance capabilities for the current task</description>
<location>project</location>
</skill>

<skill>
<name>slash-command-builder</name>
<description>Use when creating, improving, or troubleshooting Claude Code slash commands. Expert guidance on command structure, arguments, frontmatter, tool permissions, and best practices for building effective custom commands.</description>
<location>project</location>
</skill>

<skill>
<name>thoroughness</name>
<description>Use when implementing complex multi-step tasks, fixing critical bugs, or when quality and completeness matter more than speed - ensures comprehensive implementation without shortcuts through systematic analysis, implementation, and verification phases</description>
<location>project</location>
</skill>

<skill>
<name>typescript-hook-writer</name>
<description>Expert guidance for developing Claude Code hooks in TypeScript with shared utilities, esbuild compilation, and Vitest testing - distributes compiled JS while maintaining TypeScript development experience</description>
<location>project</location>
</skill>

<skill>
<name>typescript-type-safety</name>
<description>Use when encountering TypeScript any types, type errors, or lax type checking - eliminates type holes and enforces strict type safety through proper interfaces, type guards, and module augmentation</description>
<location>project</location>
</skill>

</available_skills>
<!-- SKILLS_TABLE_END -->

</skills_system>



<!-- Source: .ruler/prpm-development.md -->

<!-- Package: prpm-development -->
<!-- Author: user -->
<!-- Description: Use when developing PRPM (Prompt Package Manager) - comprehensive knowledge base covering architecture, format conversion, package types, collections, quality standards, testing, and deployment -->

# Individual package

Use when developing PRPM (Prompt Package Manager) - comprehensive knowledge base covering architecture, format conversion, package types, collections, quality standards, testing, and deployment

## Mission

Build the npm/cargo/pip equivalent for AI development artifacts. Enable developers to discover, install, share, and manage prompts across Cursor, Claude Code, Continue, Windsurf, and future AI editors.

## Core Architecture

### Git Workflow - CRITICAL RULES

```bash
git checkout -b feature/your-feature-name
   # or
   git checkout -b fix/bug-description
```

## Package Types

- Knowledge and guidelines for AI assistants

- `.claude/skills/`, `.cursor/rules/`

- `@prpm/pulumi-troubleshooting`, `@typescript/best-practices`

- Autonomous AI agents for multi-step tasks

- `.claude/agents/`, `.cursor/agents/`

- `@prpm/code-reviewer`, `@cursor/debugging-agent`

- Specific instructions or constraints for AI behavior

- `.cursor/rules/`, `.cursorrules`

- `@cursor/react-conventions`, `@cursor/test-first`

- Extensions that add functionality

- `.cursor/plugins/`, `.claude/plugins/`

- Reusable prompt templates

- `.prompts/`, project-specific directories

- Multi-step automation workflows

- `.workflows/`, `.github/workflows/`

- Executable utilities and scripts

- `scripts/`, `tools/`, `.bin/`

- Reusable file and project templates

- `templates/`, project-specific directories

- Model Context Protocol servers

- `.mcp/servers/`

## Format Conversion System

- Cursor (.mdc)

- MDC frontmatter with `ruleType`, `alwaysApply`, `description`

- Markdown body

- Simple, focused on coding rules

- No structured tools/persona definitions

- Claude (agent format)

- YAML frontmatter: `name`, `description`

- Optional: `tools` (comma-separated), `model` (sonnet/opus/haiku/inherit)

- Markdown body

- Supports persona, examples, instructions

- Continue (JSON)

- JSON configuration

- Simple prompts, context rules

- Limited metadata support

- Windsurf

- Similar to Cursor

- Markdown-based

- Basic structure

- Missing tools: -10 points

- Missing persona: -5 points

- Missing examples: -5 points

- Unsupported sections: -10 points each

- Format-specific features lost: -5 points

- **Canonical ↔ Claude**: Nearly lossless (95-100%)

- **Canonical ↔ Cursor**: Lossy on tools/persona (70-85%)

- **Canonical ↔ Continue**: Most lossy (60-75%)

## Collections System

### Collection Structure

```json
{
  "id": "@collection/nextjs-pro",
  "name": "Next.js Professional Setup",
  "description": "Complete Next.js development setup",
  "category": "frontend",
  "packages": [
    {
      "packageId": "react-best-practices",
      "required": true,
      "reason": "Core React patterns"
    },
    {
      "packageId": "typescript-strict",
      "required": true,
      "reason": "Type safety"
    },
    {
      "packageId": "tailwind-helper",
      "required": false,
      "reason": "Styling utilities"
    }
  ]
}
```

### Installation Formats (Priority Order)

```bash
prpm install collections/nextjs-pro
prpm install collections/nextjs-pro@2.0.0
```

### Registry Resolution Logic

```typescript
// When scope is 'collection' (default from CLI for collections/* prefix):
if (scope === 'collection') {
  // Search across ALL scopes, prioritize by:
  // 1. Official collections (official = true)
  // 2. Verified authors (verified = true)
  // 3. Most downloads
  // 4. Most recent
  SELECT * FROM collections
  WHERE name_slug = $1
  ORDER BY official DESC, verified DESC, downloads DESC, created_at DESC
  LIMIT 1
} else {
  // Explicit scope: exact match only
  SELECT * FROM collections
  WHERE scope = $1 AND name_slug = $2
  ORDER BY created_at DESC
  LIMIT 1
}
```

### CLI Resolution Logic

```typescript
// Parse collection spec:
// - collections/nextjs-pro → scope='collection', name_slug='nextjs-pro'
// - khaliqgant/nextjs-pro → scope='khaliqgant', name_slug='nextjs-pro'
// - @khaliqgant/nextjs-pro → scope='khaliqgant', name_slug='nextjs-pro'
// - nextjs-pro → scope='collection', name_slug='nextjs-pro'

const matchWithScope = collectionSpec.match(/^@?([^/]+)\/([^/@]+)(?:@(.+))?$/);
if (matchWithScope) {
  [, scope, name_slug, version] = matchWithScope;
} else {
  // No scope: default to 'collection'
  [, name_slug, version] = collectionSpec.match(/^([^/@]+)(?:@(.+))?$/);
  scope = 'collection';
}
```

### Version Resolution

```bash
prpm install collections/nextjs-pro

prpm install collections/nextjs-pro@2.0.4

prpm install khaliqgant/nextjs-pro@2.0.4
```

### Error Handling

```bash
prpm install collections/nonexistent
```

## Quality & Ranking System

- (0-30 points):

- Total downloads (weighted by recency)

- Stars/favorites

- Trending velocity

- (0-30 points):

- User ratings (1-5 stars)

- Review sentiment

- Documentation completeness

- (0-20 points):

- Verified author badge

- Original creator vs fork

- Publisher reputation

- Security scan results

- (0-10 points):

- Last updated date (<30 days = 10 points)

- Release frequency

- Active maintenance

- (0-10 points):

- Has README

- Has examples

- Has tags

- Complete metadata

## Technical Stack

- **Commander.js**: CLI framework

- **Fastify Client**: HTTP client for registry

- **Tar**: Package tarball creation/extraction

- **Chalk**: Terminal colors

- **Ora**: Spinners for async operations

- **Fastify**: High-performance web framework

- **PostgreSQL**: Primary database with GIN indexes

- **Redis**: Caching layer for converted packages

- **GitHub OAuth**: Authentication provider

- **Docker**: Containerized deployment

- **Vitest**: Unit and integration tests

- **100% Coverage Goal**: Especially for format converters

- **Round-Trip Tests**: Ensure conversion quality

- **Fixtures**: Real-world package examples

## Testing Standards

### Key Testing Patterns

```typescript
// Format converter test
describe('toCursor', () => {
  it('preserves data in roundtrip', () => {
    const result = toCursor(canonical);
    const back = fromCursor(result.content);
    expect(back).toEqual(canonical);
  });
});

// CLI command test
describe('install', () => {
  it('downloads and installs package', async () => {
    await handleInstall('test-pkg', { as: 'cursor' });
    expect(fs.existsSync('.cursor/rules/test-pkg.md')).toBe(true);
  });
});
```

## Development Workflow

### Package Manager: npm (NOT pnpm)

```bash
npm install

npm install --workspace=@pr-pm/cli

npm test

npm run build

npm run dev --workspace=prpm
```

### Dependency Management Best Practices

```typescript
// BAD - tar-stream is imported dynamically at runtime
const tarStream = await import('tar-stream');
```

### Environment Variable Management

```bash
NEW_FEATURE_API_KEY=your-key-here
```

## Security Standards

- **No Secrets in DB**: Never store GitHub tokens, use session IDs

- **SQL Injection**: Parameterized queries only

- **Rate Limiting**: Prevent abuse of registry API

- **Content Security**: Validate package contents before publishing

## Performance Considerations

- **Batch Operations**: Use Promise.all for independent operations

- **Database Indexes**: GIN for full-text, B-tree for lookups

- **Caching Strategy**: Cache converted packages, not raw data

- **Lazy Loading**: Don't load full package data until needed

- **Connection Pooling**: Reuse PostgreSQL connections

## Deployment

### Webapp (S3 Static Export) ⚠️ CRITICAL

```typescript
// ❌ Dynamic route (doesn't work with 'use client')
     // /app/shared/[token]/page.tsx
     const params = useParams();
     const token = params.token;

     // ✅ Query string with Suspense (works with 'use client')
     // /app/shared/page.tsx
     import { Suspense } from 'react';

     function Content() {
       const searchParams = useSearchParams();
       const token = searchParams.get('token');
       // ... component logic
     }

     export default function Page() {
       return (
         <Suspense fallback={<div>Loading...</div>}>
           <Content />
         </Suspense>
       );
     }
```

### Publishing PRPM to NPM

```bash
npm version patch --workspace=prpm --workspace=@prpm/registry-client

npm version minor --workspace=prpm
```

## Common Patterns

### CLI Command Structure

```typescript
export async function handleCommand(args: Args, options: Options) {
  const startTime = Date.now();
  try {
    const config = await loadUserConfig();
    const client = getRegistryClient(config);
    const result = await client.fetchData();
    console.log('✅ Success');
    await telemetry.track({ command: 'name', success: true });
  } catch (error) {
    console.error('❌ Failed:', error.message);
    await telemetry.track({ command: 'name', success: false });
    process.exit(1);
  }
}
```

### Registry Route Structure

```typescript
server.get('/:id', {
  schema: { /* OpenAPI schema */ },
}, async (request, reply) => {
  const { id } = request.params;
  if (!id) return reply.code(400).send({ error: 'Missing ID' });
  const result = await server.pg.query('SELECT...');
  return result.rows[0];
});
```

### Format Converter Structure

```typescript
export function toFormat(pkg: CanonicalPackage): ConversionResult {
  const warnings: string[] = [];
  let qualityScore = 100;
  const content = convertSections(pkg.content.sections, warnings);
  const lossyConversion = warnings.some(w => w.includes('not supported'));
  if (lossyConversion) qualityScore -= 10;
  return { content, format: 'target', warnings, qualityScore, lossyConversion };
}
```

## Naming Conventions

- **Files**: kebab-case (`registry-client.ts`, `to-cursor.ts`)

- **Types**: PascalCase (`CanonicalPackage`, `ConversionResult`)

- **Functions**: camelCase (`getPackage`, `convertToFormat`)

- **Constants**: UPPER_SNAKE_CASE (`DEFAULT_REGISTRY_URL`)

- **Database**: snake_case (`package_id`, `created_at`)

- **API Requests/Responses**: snake_case (`package_id`, `session_id`, `created_at`)

- **Important**: All API request and response fields use snake_case to match PostgreSQL database conventions

- Internal service methods may use camelCase, but must convert to snake_case at API boundaries

- TypeScript interfaces for API types should use snake_case fields

- Examples: `PlaygroundRunRequest.package_id`, `CreditBalance.reset_at`

## Documentation Standards

- **Inline Comments**: Explain WHY, not WHAT

- **JSDoc**: Required for public APIs

- **README**: Keep examples up-to-date

- **Markdown Docs**: Use code blocks with language tags

- **Changelog**: Follow Keep a Changelog format

- **Continuous Accuracy**: Documentation must be continuously updated and tended to for accuracy

- When adding features, update relevant docs immediately

- When fixing bugs, check if docs need corrections

- When refactoring, verify examples still work

- Review docs quarterly for outdated information

- Keep CLI docs, README, and Mintlify docs in sync

## Overview

Complete knowledge base for developing PRPM - the universal package manager for AI prompts, agents, and rules.

## Reference Documentation

- `format-conversion.md` - Complete format conversion specs

- `package-types.md` - All package types with examples

- `collections.md` - Collections system and examples

- `quality-ranking.md` - Quality and ranking algorithms

- `testing-guide.md` - Testing patterns and standards

- `deployment.md` - Deployment procedures



<!-- Source: .ruler/thoroughness.md -->

<!-- Package: thoroughness -->
<!-- Author: user -->
<!-- Description: Use when implementing complex multi-step tasks, fixing critical bugs, or when quality and completeness matter more than speed - ensures comprehensive implementation without shortcuts through systematic analysis, implementation, and verification phases -->

# Thoroughness

Use when implementing complex multi-step tasks, fixing critical bugs, or when quality and completeness matter more than speed - ensures comprehensive implementation without shortcuts through systematic analysis, implementation, and verification phases

## Purpose

This skill ensures comprehensive, complete implementation of complex tasks without shortcuts. Use this when quality and completeness matter more than speed.

## When to Use

- Fixing critical bugs or compilation errors

- Implementing complex multi-step features

- Debugging test failures

- Refactoring large codebases

- Production deployments

- Any task where shortcuts could cause future problems

## Methodology

- **Identify All Issues**

- List every error, warning, and failing test

- Group related issues together

- Prioritize by dependency order

- Create issue hierarchy (what blocks what)

- **Root Cause Analysis**

- Don't fix symptoms, find root causes

- Trace errors to their source

- Identify patterns in failures

- Document assumptions that were wrong

- **Create Detailed Plan**

- Break down into atomic steps

- Estimate time for each step

- Identify dependencies between steps

- Plan verification for each step

- Schedule breaks/checkpoints

- **Fix Issues in Dependency Order**

- Start with foundational issues

- Fix one thing completely before moving on

- Test after each fix

- Document what was changed and why

- **Verify Each Fix**

- Write/run tests for the specific fix

- Check for side effects

- Verify related functionality still works

- Document test results

- **Track Progress**

- Mark issues as completed

- Update plan with new discoveries

- Adjust time estimates

- Note any blockers immediately

- **Run All Tests**

- Unit tests

- Integration tests

- E2E tests

- Manual verification

- **Cross-Check Everything**

- Review all changed files

- Verify compilation succeeds

- Check for console errors/warnings

- Test edge cases

- **Documentation**

- Update relevant docs

- Add inline comments for complex fixes

- Document known limitations

- Create issues for future work

## Anti-Patterns to Avoid

- ❌ Fixing multiple unrelated issues at once

- ❌ Moving on before verifying a fix works

- ❌ Assuming similar errors have the same cause

- ❌ Skipping test writing "to save time"

- ❌ Copy-pasting solutions without understanding

- ❌ Ignoring warnings "because it compiles"

- ❌ Making changes without reading existing code first

## Quality Checkpoints

- [ ] Can I explain why this fix works?

- [ ] Have I tested this specific change?

- [ ] Are there any side effects?

- [ ] Is this the root cause or a symptom?

- [ ] Will this prevent similar issues in the future?

- [ ] Is the code readable and maintainable?

- [ ] Have I documented non-obvious decisions?

## Example Workflow

### Bad Approach (Shortcut-Driven)

*Bad example*

```
1. See 24 TypeScript errors
2. Add @ts-ignore to all of them
3. Hope tests pass
4. Move on
```

### Good Approach (Thoroughness-Driven)

*Good example*

```
1. List all 24 errors systematically
2. Group by error type (7 missing types, 10 unknown casts, 7 property access)
3. Find root causes:
   - Missing @types/tar package
   - No type assertions on fetch responses
   - Implicit any types in callbacks
4. Fix by category:
   - Install @types/tar (fixes 7 errors)
   - Add proper type assertions to registry-client.ts (fixes 10 errors)
   - Add explicit parameter types (fixes 7 errors)
5. Test after each category
6. Run full test suite
7. Document what was learned
```

## Time Investment

- Initial: 2-3x slower than shortcuts

- Long-term: 10x faster (no debugging later, no rework)

- Quality: Near-perfect first time

- Maintenance: Minimal

## Success Metrics

- ✅ 100% of tests passing

- ✅ Zero warnings in production build

- ✅ All code has test coverage

- ✅ Documentation is complete and accurate

- ✅ No known issues or TODOs left behind

- ✅ Future developers can understand the code

## Mantras

- "Slow is smooth, smooth is fast"

- "Do it right the first time"

- "Test everything, assume nothing"

- "Document for your future self"

- "Root causes, not symptoms"



<!-- Source: .ruler/typescript-type-safety.md -->

<!-- Package: typescript-type-safety -->
<!-- Author: user -->
<!-- Description: Use when encountering TypeScript any types, type errors, or lax type checking - eliminates type holes and enforces strict type safety through proper interfaces, type guards, and module augmentation -->

# TypeScript Type Safety

Use when encountering TypeScript any types, type errors, or lax type checking - eliminates type holes and enforces strict type safety through proper interfaces, type guards, and module augmentation

## Overview

**Zero tolerance for `any` types.** Every `any` is a runtime bug waiting to happen.

Replace `any` with proper types using interfaces, `unknown` with type guards, or generic constraints. Use `@ts-expect-error` with explanation only when absolutely necessary.

## When to Use

- Use when you see:

- `: any` in function parameters or return types

- `as any` type assertions

- TypeScript errors you're tempted to ignore

- External libraries without proper types

- Catch blocks with implicit `any`

- Don't use for:

- Already properly typed code

- Third-party `.d.ts` files (contribute upstream instead)

## Type Safety Hierarchy

**Prefer in this order:**
1. Explicit interface/type definition
2. Generic type parameters with constraints
3. Union types
4. `unknown` (with type guards)
5. `never` (for impossible states)

**Never use:** `any`

## Quick Reference

| Pattern | Bad | Good |
|---------|-----|------|
| **Error handling** | `catch (error: any)` | `catch (error) { if (error instanceof Error) ... }` |
| **Unknown data** | `JSON.parse(str) as any` | `const data = JSON.parse(str); if (isValid(data)) ...` |
| **Type assertions** | `(request as any).user` | `(request as AuthRequest).user` |
| **Double casting** | `return data as unknown as Type` | Align interfaces instead: make types compatible |
| **External libs** | `const server = fastify() as any` | `declare module 'fastify' { ... }` |
| **Generics** | `function process(data: any)` | `function process<T extends Record<string, unknown>>(data: T)` |

## Implementation

### Error Handling

```typescript
// ❌ BAD
try {
  await operation();
} catch (error: any) {
  console.error(error.message);
}

// ✅ GOOD - Use unknown and type guard
try {
  await operation();
} catch (error) {
  if (error instanceof Error) {
    console.error(error.message);
  } else {
    console.error('Unknown error:', String(error));
  }
}

// ✅ BETTER - Helper function
function toError(error: unknown): Error {
  if (error instanceof Error) return error;
  return new Error(String(error));
}

try {
  await operation();
} catch (error) {
  const err = toError(error);
  console.error(err.message);
}
```

### Unknown Data Validation

```typescript
// ❌ BAD
const data = await response.json() as any;
console.log(data.user.name);

// ✅ GOOD - Type guard
interface UserResponse {
  user: {
    name: string;
    email: string;
  };
}

function isUserResponse(data: unknown): data is UserResponse {
  return (
    typeof data === 'object' &&
    data !== null &&
    'user' in data &&
    typeof data.user === 'object' &&
    data.user !== null &&
    'name' in data.user &&
    typeof data.user.name === 'string'
  );
}

const data = await response.json();
if (isUserResponse(data)) {
  console.log(data.user.name); // Type-safe
}
```

### Module Augmentation

```typescript
// ❌ BAD
const user = (request as any).user;
const db = (server as any).pg;

// ✅ GOOD - Augment third-party types
import { FastifyRequest, FastifyInstance } from 'fastify';

interface AuthUser {
  user_id: string;
  username: string;
  email: string;
}

declare module 'fastify' {
  interface FastifyRequest {
    user?: AuthUser;
  }

  interface FastifyInstance {
    pg: PostgresPlugin;
  }
}

// Now type-safe everywhere
const user = request.user; // AuthUser | undefined
const db = server.pg;      // PostgresPlugin
```

### Generic Constraints

```typescript
// ❌ BAD
function merge(a: any, b: any): any {
  return { ...a, ...b };
}

// ✅ GOOD - Constrained generic
function merge<
  T extends Record<string, unknown>,
  U extends Record<string, unknown>
>(a: T, b: U): T & U {
  return { ...a, ...b };
}
```

### Type Alignment (Avoid Double Casts)

```typescript
// ❌ BAD - Double cast indicates misaligned types
interface SearchPackage {
  id: string;
  type: string;  // Too loose
}

interface RegistryPackage {
  id: string;
  type: PackageType;  // Specific enum
}

return data.packages as unknown as RegistryPackage[];  // Hiding incompatibility

// ✅ GOOD - Align types from the source
interface SearchPackage {
  id: string;
  type: PackageType;  // Use same specific type
}

interface RegistryPackage {
  id: string;
  type: PackageType;  // Now compatible
}

return data.packages;  // No cast needed - types match
```

## Common Mistakes

| Mistake | Why It Fails | Fix |
|---------|--------------|-----|
| Using `any` for third-party libs | Loses all type safety | Use module augmentation or `@types/*` package |
| `as any` for complex types | Hides real type errors | Create proper interface or use `unknown` |
| `as unknown as Type` double casts | Misaligned interfaces | Align types at source - same enums/unions |
| Skipping catch block types | Unsafe error access | Use `unknown` with type guards or toError helper |
| Generic functions without constraints | Allows invalid operations | Add `extends` constraint |
| Ignoring `ts-ignore` accumulation | Tech debt compounds | Fix root cause, use `@ts-expect-error` with comment |

## TSConfig Strict Settings

### Enable all strict options for maximum type safety:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

## Type Audit Workflow

1. **Find**: `grep -r ": any\|as any" --include="*.ts" src/`
2. **Categorize**: Group by pattern (errors, requests, external libs)
3. **Define**: Create interfaces/types for each category
4. **Replace**: Systematic replacement with proper types
5. **Validate**: `npm run build` must succeed
6. **Test**: All tests must pass

## Real-World Impact

- Before type safety:

- Runtime errors from undefined properties

- Silent failures from type mismatches

- Hours debugging production issues

- Difficult refactoring

- After type safety:

- Errors caught at compile time

- IntelliSense shows all available properties

- Confident refactoring with compiler help

- Self-documenting code

- Type safety isn't about making TypeScript happy - it's about preventing runtime bugs. Every `any` you eliminate is a production bug you prevent.
