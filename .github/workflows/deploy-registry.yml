name: Deploy Registry Application

on:
  push:
    branches:
      - main
    paths:
      - 'packages/registry/**'
      - 'packages/types/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-west-2
  NODE_VERSION: '20'

jobs:
  deploy:
    name: Deploy Registry to Beanstalk (${{ github.event.inputs.environment || 'dev' }})
    runs-on: ubuntu-latest

    # Prevent concurrent deployments to same environment
    concurrency:
      group: deploy-${{ github.event.inputs.environment || 'prod' }}
      cancel-in-progress: false

    defaults:
      run:
        working-directory: packages/registry

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set environment variables
        id: env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_OUTPUT

          # Set Beanstalk app/env names based on Pulumi outputs
          if [ "$ENVIRONMENT" = "prod" ]; then
            echo "EB_APP_NAME=prpm-prod" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-prod-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-prod-packages" >> $GITHUB_OUTPUT
          elif [ "$ENVIRONMENT" = "staging" ]; then
            echo "EB_APP_NAME=prpm-staging" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-staging-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-deployments-staging" >> $GITHUB_OUTPUT
          else
            echo "EB_APP_NAME=prpm-dev" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-dev-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-deployments-dev" >> $GITHUB_OUTPUT
          fi

      # CRITICAL: Check environment health before deploying
      - name: Check Beanstalk environment status
        id: check_env
        run: |
          echo "Checking environment: ${{ steps.env.outputs.EB_ENV_NAME }}"

          ENV_STATUS=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].Status" \
            --output text 2>/dev/null || echo "NotFound")

          ENV_HEALTH=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].Health" \
            --output text 2>/dev/null || echo "Unknown")

          echo "Environment Status: $ENV_STATUS"
          echo "Environment Health: $ENV_HEALTH"

          if [ "$ENV_STATUS" = "NotFound" ]; then
            echo "‚ö†Ô∏è  Environment does not exist. Please provision infrastructure first."
            exit 1
          fi

          if [ "$ENV_STATUS" != "Ready" ]; then
            echo "‚ùå Environment not ready. Status: $ENV_STATUS"
            echo "Please wait for environment to be Ready or check for issues."
            exit 1
          fi

          if [ "$ENV_HEALTH" = "Red" ]; then
            echo "‚ö†Ô∏è  WARNING: Environment health is Red"
            echo "Proceeding with caution. Monitor deployment closely."
          fi

          echo "‚úÖ Environment is ready for deployment"

      - name: Install dependencies
        working-directory: .
        run: |
          echo "Installing root dependencies..."
          npm ci --quiet

          echo "Installing types dependencies..."
          cd packages/types
          npm ci --quiet

          echo "Installing registry dependencies..."
          cd ../registry
          npm ci --quiet

      - name: Build types package
        working-directory: packages/types
        run: |
          echo "Building types package..."
          npm run build

          if [ ! -d "dist" ]; then
            echo "‚ùå Types build failed - dist directory not found"
            exit 1
          fi

          echo "‚úÖ Types built successfully"

      - name: Build application
        working-directory: packages/registry
        run: |
          echo "Building registry application..."
          npm run build

          if [ ! -d "dist" ]; then
            echo "‚ùå Build failed - dist directory not found"
            exit 1
          fi

          echo "‚úÖ Build completed successfully"

      - name: Create deployment package
        working-directory: packages/registry
        run: |
          VERSION_LABEL="v${{ github.run_number }}-$(echo ${{ github.sha }} | cut -c1-7)"
          echo "VERSION_LABEL=$VERSION_LABEL" >> $GITHUB_ENV

          echo "Creating deployment package: ${VERSION_LABEL}.zip"

          # Include @prpm/types as a local file dependency since it's a workspace package
          echo "Copying @prpm/types to .types directory..."
          mkdir -p .types
          cp -r ../types/* .types/

          # Verify types package was copied
          if [ ! -d ".types/dist" ]; then
            echo "‚ùå Failed to copy types package"
            exit 1
          fi

          echo "‚úÖ Types package copied successfully"

          # Modify package.json to use file: dependency for @prpm/types
          echo "Updating package.json to use local types..."
          cp package.json package.json.bak
          cat package.json | jq '.dependencies["@prpm/types"] = "file:.types"' > package.json.tmp
          mv package.json.tmp package.json

          # Show the change
          echo "Modified dependency:"
          jq '.dependencies["@prpm/types"]' package.json

          zip -r ${VERSION_LABEL}.zip \
            dist/ \
            package.json \
            package-lock.json \
            .ebextensions/ \
            .platform/ \
            migrations/ \
            scripts/ \
            .types/ \
            -x "*.git*" \
            -x "*.md" \
            -x "*.test.*" \
            -x "*.spec.*" \
            -x "*node_modules*" \
            -q

          # Restore original package.json
          mv package.json.bak package.json

          ls -lh ${VERSION_LABEL}.zip
          echo "‚úÖ Deployment package created with @prpm/types as file dependency"

      - name: Upload to S3
        working-directory: packages/registry
        run: |
          S3_KEY="deployments/${VERSION_LABEL}.zip"
          echo "Uploading to s3://${{ steps.env.outputs.S3_BUCKET }}/${S3_KEY}"

          aws s3 cp ${VERSION_LABEL}.zip s3://${{ steps.env.outputs.S3_BUCKET }}/${S3_KEY} \
            --metadata "git-sha=${{ github.sha }},run-number=${{ github.run_number }},environment=${{ steps.env.outputs.ENVIRONMENT }}"

          echo "‚úÖ Uploaded to S3"

      - name: Create Beanstalk application version
        run: |
          echo "Creating application version: $VERSION_LABEL"

          aws elasticbeanstalk create-application-version \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --version-label $VERSION_LABEL \
            --source-bundle S3Bucket="${{ steps.env.outputs.S3_BUCKET }}",S3Key="deployments/${VERSION_LABEL}.zip" \
            --description "Deployed from GitHub Actions run ${{ github.run_number }} (SHA: ${{ github.sha }})" \
            --process

          echo "‚úÖ Application version created"

      - name: Get current environment configuration
        id: current_config
        run: |
          # Get current version for potential rollback
          CURRENT_VERSION=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].VersionLabel" \
            --output text)

          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Deploy to Beanstalk environment
        run: |
          echo "Deploying version $VERSION_LABEL to ${{ steps.env.outputs.EB_ENV_NAME }}"

          aws elasticbeanstalk update-environment \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
            --version-label $VERSION_LABEL

          echo "‚úÖ Deployment initiated"

      # CRITICAL: Wait for deployment to complete with proper timeout
      - name: Wait for deployment completion
        timeout-minutes: 15
        run: |
          echo "‚è≥ Waiting for deployment to complete..."
          echo "This may take 5-10 minutes depending on deployment policy."

          for i in {1..90}; do
            STATUS=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
              --query "Environments[0].Status" \
              --output text)

            HEALTH=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
              --query "Environments[0].Health" \
              --output text)

            VERSION=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
              --query "Environments[0].VersionLabel" \
              --output text)

            echo "[$i/90] Status: $STATUS | Health: $HEALTH | Version: $VERSION"

            # Check if deployment completed successfully
            if [ "$STATUS" = "Ready" ] && [ "$VERSION" = "$VERSION_LABEL" ]; then
              if [ "$HEALTH" = "Green" ]; then
                echo "‚úÖ Deployment successful! Environment is healthy."
                exit 0
              elif [ "$HEALTH" = "Yellow" ]; then
                echo "‚ö†Ô∏è  Deployment complete but health is Yellow. Proceeding with verification."
                exit 0
              fi
            fi

            # Check for failure conditions
            if [ "$STATUS" = "Ready" ] && [ "$VERSION" != "$VERSION_LABEL" ] && [ $i -gt 10 ]; then
              echo "‚ùå Deployment failed - version did not update"
              echo "Current: $VERSION, Expected: $VERSION_LABEL"
              exit 1
            fi

            if [ "$HEALTH" = "Red" ] && [ $i -gt 5 ]; then
              echo "‚ùå Environment health is Red"

              # Get recent events
              echo "Recent events:"
              aws elasticbeanstalk describe-events \
                --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
                --max-records 10 \
                --query 'Events[*].[EventDate,Severity,Message]' \
                --output table

              exit 1
            fi

            sleep 10
          done

          echo "‚ùå Deployment timed out after 15 minutes"
          exit 1

      # CRITICAL: Verify health endpoint
      - name: Verify application health
        timeout-minutes: 5
        run: |
          echo "Verifying application health endpoint..."

          ENDPOINT=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].CNAME" \
            --output text)

          echo "Endpoint: http://${ENDPOINT}"

          for i in {1..30}; do
            echo "[$i/30] Testing health endpoint..."

            if curl -sf "http://${ENDPOINT}/health" -o /dev/null; then
              echo "‚úÖ Health check passed"

              # Test a key API endpoint
              if curl -sf "http://${ENDPOINT}/api/v1/packages?limit=1" -o /dev/null; then
                echo "‚úÖ API endpoint working"
                exit 0
              else
                echo "‚ö†Ô∏è  Health passed but API endpoint not responding"
              fi
            fi

            sleep 10
          done

          echo "‚ùå Health check failed after 5 minutes"
          echo "Rolling back to previous version..."

          # Attempt rollback
          aws elasticbeanstalk update-environment \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
            --version-label ${{ steps.current_config.outputs.CURRENT_VERSION }}

          exit 1

      - name: Get deployment summary
        if: success()
        run: |
          ENDPOINT=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].CNAME" \
            --output text)

          HEALTH=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].Health" \
            --output text)

          echo "## üöÄ Deployment Successful"
          echo ""
          echo "**Environment:** ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "**Version:** $VERSION_LABEL"
          echo "**Health:** $HEALTH"
          echo "**Endpoint:** http://${ENDPOINT}"
          echo ""
          echo "**Health Check:** http://${ENDPOINT}/health"
          echo "**API Docs:** http://${ENDPOINT}/docs"
          echo ""
          echo "**Deployed at:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "**Git SHA:** ${{ github.sha }}"
          echo "**Run Number:** ${{ github.run_number }}"

      - name: Cleanup old application versions
        if: success()
        run: |
          echo "Cleaning up old application versions (keeping last 10)..."

          # Get all versions sorted by date
          VERSIONS=$(aws elasticbeanstalk describe-application-versions \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --query 'ApplicationVersions | sort_by(@, &DateCreated) | [*].VersionLabel' \
            --output text)

          VERSION_COUNT=$(echo "$VERSIONS" | wc -w)

          if [ $VERSION_COUNT -gt 10 ]; then
            VERSIONS_TO_DELETE=$(echo "$VERSIONS" | tr ' ' '\n' | head -n -10)

            for VERSION in $VERSIONS_TO_DELETE; do
              # Don't delete if it's currently deployed in any environment
              IN_USE=$(aws elasticbeanstalk describe-environments \
                --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
                --query "Environments[?VersionLabel=='$VERSION'].EnvironmentName" \
                --output text)

              if [ -z "$IN_USE" ]; then
                echo "Deleting old version: $VERSION"
                aws elasticbeanstalk delete-application-version \
                  --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
                  --version-label $VERSION \
                  --delete-source-bundle
              else
                echo "Skipping $VERSION (in use by $IN_USE)"
              fi
            done
          fi

          echo "‚úÖ Cleanup complete"

      - name: Post deployment notification
        if: success()
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "Environment: ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "Version: $VERSION_LABEL"
          # Add Slack/Discord/email notification here if needed

      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          echo "Environment: ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "Version: $VERSION_LABEL"

          # Get recent error events
          echo "Recent error events:"
          aws elasticbeanstalk describe-events \
            --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
            --severity ERROR \
            --max-records 20 \
            --query 'Events[*].[EventDate,Message]' \
            --output table

          # Add Slack/Discord/PagerDuty notification here

      - name: Save deployment artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ steps.env.outputs.ENVIRONMENT }}-${{ github.run_number }}
          path: packages/registry/${{ env.VERSION_LABEL }}.zip
          retention-days: 7
