name: Deploy

on:
  push:
    branches: [main]
    paths:
      - 'packages/registry/**'
      - 'packages/types/**'
      - 'packages/webapp/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod
      deploy_target:
        description: 'What to deploy'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - registry-only
          - webapp-only

env:
  AWS_REGION: us-west-2
  NODE_VERSION: '20'

jobs:
  # Check what changed
  changes:
    runs-on: ubuntu-latest
    outputs:
      registry: ${{ steps.filter.outputs.registry }}
      webapp: ${{ steps.filter.outputs.webapp }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            registry:
              - 'packages/registry/**'
              - 'packages/types/**'
            webapp:
              - 'packages/webapp/**'

  # Deploy registry first (if changed or manually requested)
  deploy-registry:
    name: Deploy Registry
    needs: changes
    if: |
      needs.changes.outputs.registry == 'true' ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.deploy_target == 'all' || github.event.inputs.deploy_target == 'registry-only'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Build types
        run: npm run build --workspace=@pr-pm/types

      - name: Build registry
        run: npm run build --workspace=@pr-pm/registry

      - name: Set environment variables
        id: env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_OUTPUT

          # Set Beanstalk app/env names and S3 bucket based on environment
          if [ "$ENVIRONMENT" = "prod" ]; then
            echo "EB_APP_NAME=prpm-prod" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-prod-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-prod-packages" >> $GITHUB_OUTPUT
          elif [ "$ENVIRONMENT" = "staging" ]; then
            echo "EB_APP_NAME=prpm-staging" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-staging-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-deployments-staging" >> $GITHUB_OUTPUT
          else
            echo "EB_APP_NAME=prpm-dev" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-dev-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-deployments-dev" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment package
        run: |
          cd packages/registry
          VERSION_LABEL="v-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
          echo "VERSION_LABEL=$VERSION_LABEL" >> $GITHUB_ENV
          zip -r ${VERSION_LABEL}.zip . -x "*.git*" "node_modules/*" "src/*" "*.test.ts" "*.spec.ts"
          echo "âœ… Created deployment package: ${VERSION_LABEL}.zip"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload to S3
        working-directory: packages/registry
        run: |
          S3_KEY="deployments/${VERSION_LABEL}.zip"
          echo "Uploading to s3://${{ steps.env.outputs.S3_BUCKET }}/${S3_KEY}"

          aws s3 cp ${VERSION_LABEL}.zip s3://${{ steps.env.outputs.S3_BUCKET }}/${S3_KEY} \
            --metadata "git-sha=${{ github.sha }},run-number=${{ github.run_number }},environment=${{ steps.env.outputs.ENVIRONMENT }}"

          echo "âœ… Uploaded to S3"

      - name: Create Beanstalk application version
        run: |
          echo "Creating application version: $VERSION_LABEL"

          aws elasticbeanstalk create-application-version \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --version-label $VERSION_LABEL \
            --source-bundle S3Bucket="${{ steps.env.outputs.S3_BUCKET }}",S3Key="deployments/${VERSION_LABEL}.zip" \
            --description "Deployed from GitHub Actions run ${{ github.run_number }} (SHA: ${{ github.sha }})" \
            --process

          echo "âœ… Application version created"

      - name: Deploy to Beanstalk environment
        run: |
          echo "Deploying to environment: ${{ steps.env.outputs.EB_ENV_NAME }}"

          aws elasticbeanstalk update-environment \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
            --version-label $VERSION_LABEL

          echo "âœ… Deployment initiated"

      - name: Wait for deployment
        run: |
          echo "Waiting for environment to update..."

          MAX_ATTEMPTS=40  # 40 attempts Ã— 30 seconds = 20 minutes max
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "â³ Check $ATTEMPT/$MAX_ATTEMPTS..."

            # Get environment status and health
            ENV_INFO=$(aws elasticbeanstalk describe-environments \
              --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
              --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
              --query 'Environments[0].[Status,Health,HealthStatus]' \
              --output text)

            STATUS=$(echo "$ENV_INFO" | awk '{print $1}')
            HEALTH=$(echo "$ENV_INFO" | awk '{print $2}')
            HEALTH_STATUS=$(echo "$ENV_INFO" | awk '{print $3}')

            echo "   Status: $STATUS | Health: $HEALTH | HealthStatus: $HEALTH_STATUS"

            # Check if deployment is complete
            if [ "$STATUS" = "Ready" ]; then
              if [ "$HEALTH" = "Green" ]; then
                echo "âœ… Environment is Ready and Healthy"
                break
              elif [ "$HEALTH" = "Yellow" ]; then
                echo "âš ï¸  Environment is Ready but has warnings (Yellow health)"
                echo "   Checking if this is acceptable..."

                # Give it a few more checks to potentially turn Green
                if [ $ATTEMPT -gt 10 ]; then
                  echo "âš ï¸  Proceeding with Yellow health status"
                  break
                fi
              else
                echo "âŒ Environment is Ready but health is: $HEALTH"

                # Get recent events for debugging
                echo "Recent events:"
                aws elasticbeanstalk describe-events \
                  --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
                  --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
                  --max-records 5 \
                  --query 'Events[].[EventDate,Severity,Message]' \
                  --output text | head -20

                exit 1
              fi
            elif [ "$STATUS" = "Updating" ]; then
              echo "   Still updating, waiting 30 seconds..."
            else
              echo "âŒ Unexpected status: $STATUS"

              # Get recent events for debugging
              echo "Recent events:"
              aws elasticbeanstalk describe-events \
                --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
                --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
                --max-records 10 \
                --query 'Events[].[EventDate,Severity,Message]' \
                --output text | head -30

              exit 1
            fi

            sleep 30
          done

          if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
            echo "âŒ Deployment timed out after $MAX_ATTEMPTS attempts ($(($MAX_ATTEMPTS * 30 / 60)) minutes)"

            # Get recent events for debugging
            echo "Recent events:"
            aws elasticbeanstalk describe-events \
              --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
              --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
              --max-records 20 \
              --query 'Events[].[EventDate,Severity,Message]' \
              --output text

            exit 1
          fi

          echo "âœ“ Registry deployment completed"

      - name: Health check
        run: |
          echo "Waiting 30 seconds for environment to stabilize..."
          sleep 30

          echo "Running health checks..."
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://registry.prpm.dev/health)

          if [ "$STATUS" -ne 200 ]; then
            echo "Error: Health check returned status $STATUS"
            exit 1
          fi

          echo "âœ“ Registry is healthy (HTTP $STATUS)"

  # Deploy webapp second (if changed or manually requested), only after registry succeeds or is skipped
  # This job depends on deploy-registry but will run even if that job is skipped
  deploy-webapp:
    name: Deploy WebApp
    needs: [changes, deploy-registry]
    # Run if:
    # 1. Webapp changed OR manually deploying webapp
    # 2. AND registry either succeeded or was skipped (not run or not failed)
    if: |
      always() &&
      (needs.changes.outputs.webapp == 'true' ||
       (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.deploy_target == 'all' || github.event.inputs.deploy_target == 'webapp-only'))) &&
      (needs.deploy-registry.result == 'success' || needs.deploy-registry.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install root dependencies
        run: npm ci

      - name: Build types package
        run: npm run build --workspace=@pr-pm/types

      - name: Build webapp
        env:
          REGISTRY_URL: https://registry.prpm.dev
        run: |
          cd packages/webapp
          npm ci
          npm run build

      - name: Verify build output
        run: |
          if [ ! -d "packages/webapp/out" ]; then
            echo "Error: Build output directory does not exist"
            exit 1
          fi

          if [ ! -f "packages/webapp/out/index.html" ]; then
            echo "Error: index.html not found in build output"
            exit 1
          fi

          echo "âœ“ Build output verified"
          find packages/webapp/out -type f | head -20

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          # Sync new files (without delete) to ensure all chunks are uploaded
          aws s3 sync packages/webapp/out/ s3://prpm-prod-webapp/ \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.html" \
            --exclude "_next/data/*"

          # Sync HTML files with NO CACHE
          aws s3 sync packages/webapp/out/ s3://prpm-prod-webapp/ \
            --cache-control "no-cache, no-store, must-revalidate" \
            --exclude "*" \
            --include "*.html" \
            --include "_next/data/*"

          # Delete old files after everything is uploaded
          aws s3 sync packages/webapp/out/ s3://prpm-prod-webapp/ --delete

          echo "âœ“ WebApp deployed to S3"

      - name: Invalidate CloudFront
        run: |
          DIST_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Aliases.Items[?contains(@, 'prpm.dev')]].Id" \
            --output text)

          echo "Creating CloudFront invalidation for distribution: $DIST_ID"

          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id $DIST_ID \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)

          echo "Invalidation created: $INVALIDATION_ID"
          echo "Waiting for invalidation to complete..."

          aws cloudfront wait invalidation-completed \
            --distribution-id $DIST_ID \
            --id $INVALIDATION_ID

          echo "âœ“ CloudFront invalidation completed"

      - name: Health check
        run: |
          echo "Running health checks..."

          STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://prpm.dev)
          if [ "$STATUS" -ne 200 ]; then
            echo "Error: Homepage returned status $STATUS"
            exit 1
          fi
          echo "âœ“ Homepage is accessible (HTTP $STATUS)"

          for page in "/search" "/authors" "/blog"; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://prpm.dev$page")
            if [ "$STATUS" -ne 200 ]; then
              echo "Warning: $page returned status $STATUS"
            else
              echo "âœ“ $page is accessible (HTTP $STATUS)"
            fi
          done

  # Summary of what was deployed
  summary:
    name: Deployment Summary
    needs: [changes, deploy-registry, deploy-webapp]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Create summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.changes.outputs.registry }}" == "true" ]; then
            if [ "${{ needs.deploy-registry.result }}" == "success" ]; then
              echo "âœ… **Registry**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **Registry**: Deployment failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "â­ï¸ **Registry**: No changes, skipped" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ needs.changes.outputs.webapp }}" == "true" ]; then
            if [ "${{ needs.deploy-webapp.result }}" == "success" ]; then
              echo "âœ… **WebApp**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **WebApp**: Deployment failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "â­ï¸ **WebApp**: No changes, skipped" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: \`${GITHUB_SHA:0:7}\`" >> $GITHUB_STEP_SUMMARY
